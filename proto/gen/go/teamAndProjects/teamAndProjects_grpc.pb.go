// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.3
// source: teamAndProjects/teamAndProjects.proto

package workspacev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Teams_CreateTeam_FullMethodName       = "/workspace.v1.Teams/CreateTeam"
	Teams_GetTeam_FullMethodName          = "/workspace.v1.Teams/GetTeam"
	Teams_UpdateTeam_FullMethodName       = "/workspace.v1.Teams/UpdateTeam"
	Teams_DeleteTeam_FullMethodName       = "/workspace.v1.Teams/DeleteTeam"
	Teams_ListTeams_FullMethodName        = "/workspace.v1.Teams/ListTeams"
	Teams_ListTeamMembers_FullMethodName  = "/workspace.v1.Teams/ListTeamMembers"
	Teams_UpdateTeamMember_FullMethodName = "/workspace.v1.Teams/UpdateTeamMember"
	Teams_RemoveTeamMember_FullMethodName = "/workspace.v1.Teams/RemoveTeamMember"
)

// TeamsClient is the client API for Teams service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TeamsClient interface {
	// Создание команды. Обычно создатель становится founder_id
	CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*Team, error)
	GetTeam(ctx context.Context, in *GetTeamRequest, opts ...grpc.CallOption) (*Team, error)
	// Частичный апдейт команды
	UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*Team, error)
	DeleteTeam(ctx context.Context, in *DeleteTeamRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Список команд
	ListTeams(ctx context.Context, in *ListTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error)
	// Участники команды
	ListTeamMembers(ctx context.Context, in *ListTeamMembersRequest, opts ...grpc.CallOption) (*ListTeamMembersResponse, error)
	// Обновление duties участника команды (частично)
	UpdateTeamMember(ctx context.Context, in *UpdateTeamMemberRequest, opts ...grpc.CallOption) (*TeamMember, error)
	RemoveTeamMember(ctx context.Context, in *RemoveTeamMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type teamsClient struct {
	cc grpc.ClientConnInterface
}

func NewTeamsClient(cc grpc.ClientConnInterface) TeamsClient {
	return &teamsClient{cc}
}

func (c *teamsClient) CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, Teams_CreateTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamsClient) GetTeam(ctx context.Context, in *GetTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, Teams_GetTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamsClient) UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, Teams_UpdateTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamsClient) DeleteTeam(ctx context.Context, in *DeleteTeamRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Teams_DeleteTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamsClient) ListTeams(ctx context.Context, in *ListTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamsResponse)
	err := c.cc.Invoke(ctx, Teams_ListTeams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamsClient) ListTeamMembers(ctx context.Context, in *ListTeamMembersRequest, opts ...grpc.CallOption) (*ListTeamMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamMembersResponse)
	err := c.cc.Invoke(ctx, Teams_ListTeamMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamsClient) UpdateTeamMember(ctx context.Context, in *UpdateTeamMemberRequest, opts ...grpc.CallOption) (*TeamMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TeamMember)
	err := c.cc.Invoke(ctx, Teams_UpdateTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamsClient) RemoveTeamMember(ctx context.Context, in *RemoveTeamMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Teams_RemoveTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TeamsServer is the server API for Teams service.
// All implementations must embed UnimplementedTeamsServer
// for forward compatibility.
type TeamsServer interface {
	// Создание команды. Обычно создатель становится founder_id
	CreateTeam(context.Context, *CreateTeamRequest) (*Team, error)
	GetTeam(context.Context, *GetTeamRequest) (*Team, error)
	// Частичный апдейт команды
	UpdateTeam(context.Context, *UpdateTeamRequest) (*Team, error)
	DeleteTeam(context.Context, *DeleteTeamRequest) (*emptypb.Empty, error)
	// Список команд
	ListTeams(context.Context, *ListTeamsRequest) (*ListTeamsResponse, error)
	// Участники команды
	ListTeamMembers(context.Context, *ListTeamMembersRequest) (*ListTeamMembersResponse, error)
	// Обновление duties участника команды (частично)
	UpdateTeamMember(context.Context, *UpdateTeamMemberRequest) (*TeamMember, error)
	RemoveTeamMember(context.Context, *RemoveTeamMemberRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTeamsServer()
}

// UnimplementedTeamsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTeamsServer struct{}

func (UnimplementedTeamsServer) CreateTeam(context.Context, *CreateTeamRequest) (*Team, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTeam not implemented")
}
func (UnimplementedTeamsServer) GetTeam(context.Context, *GetTeamRequest) (*Team, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeam not implemented")
}
func (UnimplementedTeamsServer) UpdateTeam(context.Context, *UpdateTeamRequest) (*Team, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTeam not implemented")
}
func (UnimplementedTeamsServer) DeleteTeam(context.Context, *DeleteTeamRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTeam not implemented")
}
func (UnimplementedTeamsServer) ListTeams(context.Context, *ListTeamsRequest) (*ListTeamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTeams not implemented")
}
func (UnimplementedTeamsServer) ListTeamMembers(context.Context, *ListTeamMembersRequest) (*ListTeamMembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTeamMembers not implemented")
}
func (UnimplementedTeamsServer) UpdateTeamMember(context.Context, *UpdateTeamMemberRequest) (*TeamMember, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTeamMember not implemented")
}
func (UnimplementedTeamsServer) RemoveTeamMember(context.Context, *RemoveTeamMemberRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTeamMember not implemented")
}
func (UnimplementedTeamsServer) mustEmbedUnimplementedTeamsServer() {}
func (UnimplementedTeamsServer) testEmbeddedByValue()               {}

// UnsafeTeamsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TeamsServer will
// result in compilation errors.
type UnsafeTeamsServer interface {
	mustEmbedUnimplementedTeamsServer()
}

func RegisterTeamsServer(s grpc.ServiceRegistrar, srv TeamsServer) {
	// If the following call pancis, it indicates UnimplementedTeamsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Teams_ServiceDesc, srv)
}

func _Teams_CreateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).CreateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_CreateTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).CreateTeam(ctx, req.(*CreateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Teams_GetTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).GetTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_GetTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).GetTeam(ctx, req.(*GetTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Teams_UpdateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).UpdateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_UpdateTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).UpdateTeam(ctx, req.(*UpdateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Teams_DeleteTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).DeleteTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_DeleteTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).DeleteTeam(ctx, req.(*DeleteTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Teams_ListTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).ListTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_ListTeams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).ListTeams(ctx, req.(*ListTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Teams_ListTeamMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).ListTeamMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_ListTeamMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).ListTeamMembers(ctx, req.(*ListTeamMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Teams_UpdateTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).UpdateTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_UpdateTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).UpdateTeamMember(ctx, req.(*UpdateTeamMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Teams_RemoveTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveTeamMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamsServer).RemoveTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Teams_RemoveTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamsServer).RemoveTeamMember(ctx, req.(*RemoveTeamMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Teams_ServiceDesc is the grpc.ServiceDesc for Teams service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Teams_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "workspace.v1.Teams",
	HandlerType: (*TeamsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTeam",
			Handler:    _Teams_CreateTeam_Handler,
		},
		{
			MethodName: "GetTeam",
			Handler:    _Teams_GetTeam_Handler,
		},
		{
			MethodName: "UpdateTeam",
			Handler:    _Teams_UpdateTeam_Handler,
		},
		{
			MethodName: "DeleteTeam",
			Handler:    _Teams_DeleteTeam_Handler,
		},
		{
			MethodName: "ListTeams",
			Handler:    _Teams_ListTeams_Handler,
		},
		{
			MethodName: "ListTeamMembers",
			Handler:    _Teams_ListTeamMembers_Handler,
		},
		{
			MethodName: "UpdateTeamMember",
			Handler:    _Teams_UpdateTeamMember_Handler,
		},
		{
			MethodName: "RemoveTeamMember",
			Handler:    _Teams_RemoveTeamMember_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "teamAndProjects/teamAndProjects.proto",
}

const (
	Projects_CreateProject_FullMethodName             = "/workspace.v1.Projects/CreateProject"
	Projects_GetProject_FullMethodName                = "/workspace.v1.Projects/GetProject"
	Projects_UpdateProject_FullMethodName             = "/workspace.v1.Projects/UpdateProject"
	Projects_DeleteProject_FullMethodName             = "/workspace.v1.Projects/DeleteProject"
	Projects_ListProjects_FullMethodName              = "/workspace.v1.Projects/ListProjects"
	Projects_ListPublicProjects_FullMethodName        = "/workspace.v1.Projects/ListPublicProjects"
	Projects_ListProjectMembers_FullMethodName        = "/workspace.v1.Projects/ListProjectMembers"
	Projects_AddProjectMember_FullMethodName          = "/workspace.v1.Projects/AddProjectMember"
	Projects_RemoveProjectMember_FullMethodName       = "/workspace.v1.Projects/RemoveProjectMember"
	Projects_UpdateProjectMemberRights_FullMethodName = "/workspace.v1.Projects/UpdateProjectMemberRights"
	Projects_RequestJoinProject_FullMethodName        = "/workspace.v1.Projects/RequestJoinProject"
	Projects_CancelJoinProject_FullMethodName         = "/workspace.v1.Projects/CancelJoinProject"
	Projects_ListProjectJoinRequests_FullMethodName   = "/workspace.v1.Projects/ListProjectJoinRequests"
	Projects_ApproveProjectJoinRequest_FullMethodName = "/workspace.v1.Projects/ApproveProjectJoinRequest"
	Projects_RejectProjectJoinRequest_FullMethodName  = "/workspace.v1.Projects/RejectProjectJoinRequest"
)

// ProjectsClient is the client API for Projects service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectsClient interface {
	// Создать проект под конкретной командой
	// Создатель автоматически становится project_member с полными правами
	CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*Project, error)
	GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*Project, error)
	// Частичный апдейт проекта
	UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*Project, error)
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Список проектов для внутренних страниц: мои проекты, проекты команды
	ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error)
	// Публичный листинг проектов для поиска (главный сценарий)
	// Обычно отдаёт только is_open=true
	ListPublicProjects(ctx context.Context, in *ListPublicProjectsRequest, opts ...grpc.CallOption) (*ListPublicProjectsResponse, error)
	// Участники проекта
	ListProjectMembers(ctx context.Context, in *ListProjectMembersRequest, opts ...grpc.CallOption) (*ListProjectMembersResponse, error)
	// Прямое добавление участника в проект (для менеджеров проекта)
	AddProjectMember(ctx context.Context, in *AddProjectMemberRequest, opts ...grpc.CallOption) (*ProjectMember, error)
	// Удаление участника из проекта (для менеджеров проекта)
	// БД-триггер может удалить team_member, если у пользователя не осталось проектов этой команды
	RemoveProjectMember(ctx context.Context, in *RemoveProjectMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Выдача/обновление прав участника проекта (только manager_rights)
	UpdateProjectMemberRights(ctx context.Context, in *UpdateProjectMemberRightsRequest, opts ...grpc.CallOption) (*ProjectMember, error)
	// Пользователь подает заявку на вступление в проект
	RequestJoinProject(ctx context.Context, in *RequestJoinProjectRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error)
	// Пользователь отменяет свою pending заявку
	CancelJoinProject(ctx context.Context, in *CancelJoinProjectRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error)
	// Менеджеры проекта смотрят заявки
	ListProjectJoinRequests(ctx context.Context, in *ListProjectJoinRequestsRequest, opts ...grpc.CallOption) (*ListProjectJoinRequestsResponse, error)
	// Менеджер проекта одобряет заявку: создаём project_member и помечаем request approved
	ApproveProjectJoinRequest(ctx context.Context, in *ApproveProjectJoinRequestRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error)
	// Менеджер проекта отклоняет заявку
	RejectProjectJoinRequest(ctx context.Context, in *RejectProjectJoinRequestRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error)
}

type projectsClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectsClient(cc grpc.ClientConnInterface) ProjectsClient {
	return &projectsClient{cc}
}

func (c *projectsClient) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, Projects_CreateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetProject(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, Projects_GetProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, Projects_UpdateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Projects_DeleteProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProjectsResponse)
	err := c.cc.Invoke(ctx, Projects_ListProjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) ListPublicProjects(ctx context.Context, in *ListPublicProjectsRequest, opts ...grpc.CallOption) (*ListPublicProjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPublicProjectsResponse)
	err := c.cc.Invoke(ctx, Projects_ListPublicProjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) ListProjectMembers(ctx context.Context, in *ListProjectMembersRequest, opts ...grpc.CallOption) (*ListProjectMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProjectMembersResponse)
	err := c.cc.Invoke(ctx, Projects_ListProjectMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) AddProjectMember(ctx context.Context, in *AddProjectMemberRequest, opts ...grpc.CallOption) (*ProjectMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectMember)
	err := c.cc.Invoke(ctx, Projects_AddProjectMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) RemoveProjectMember(ctx context.Context, in *RemoveProjectMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Projects_RemoveProjectMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) UpdateProjectMemberRights(ctx context.Context, in *UpdateProjectMemberRightsRequest, opts ...grpc.CallOption) (*ProjectMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectMember)
	err := c.cc.Invoke(ctx, Projects_UpdateProjectMemberRights_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) RequestJoinProject(ctx context.Context, in *RequestJoinProjectRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectJoinRequest)
	err := c.cc.Invoke(ctx, Projects_RequestJoinProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) CancelJoinProject(ctx context.Context, in *CancelJoinProjectRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectJoinRequest)
	err := c.cc.Invoke(ctx, Projects_CancelJoinProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) ListProjectJoinRequests(ctx context.Context, in *ListProjectJoinRequestsRequest, opts ...grpc.CallOption) (*ListProjectJoinRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProjectJoinRequestsResponse)
	err := c.cc.Invoke(ctx, Projects_ListProjectJoinRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) ApproveProjectJoinRequest(ctx context.Context, in *ApproveProjectJoinRequestRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectJoinRequest)
	err := c.cc.Invoke(ctx, Projects_ApproveProjectJoinRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) RejectProjectJoinRequest(ctx context.Context, in *RejectProjectJoinRequestRequest, opts ...grpc.CallOption) (*ProjectJoinRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectJoinRequest)
	err := c.cc.Invoke(ctx, Projects_RejectProjectJoinRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectsServer is the server API for Projects service.
// All implementations must embed UnimplementedProjectsServer
// for forward compatibility.
type ProjectsServer interface {
	// Создать проект под конкретной командой
	// Создатель автоматически становится project_member с полными правами
	CreateProject(context.Context, *CreateProjectRequest) (*Project, error)
	GetProject(context.Context, *GetProjectRequest) (*Project, error)
	// Частичный апдейт проекта
	UpdateProject(context.Context, *UpdateProjectRequest) (*Project, error)
	DeleteProject(context.Context, *DeleteProjectRequest) (*emptypb.Empty, error)
	// Список проектов для внутренних страниц: мои проекты, проекты команды
	ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error)
	// Публичный листинг проектов для поиска (главный сценарий)
	// Обычно отдаёт только is_open=true
	ListPublicProjects(context.Context, *ListPublicProjectsRequest) (*ListPublicProjectsResponse, error)
	// Участники проекта
	ListProjectMembers(context.Context, *ListProjectMembersRequest) (*ListProjectMembersResponse, error)
	// Прямое добавление участника в проект (для менеджеров проекта)
	AddProjectMember(context.Context, *AddProjectMemberRequest) (*ProjectMember, error)
	// Удаление участника из проекта (для менеджеров проекта)
	// БД-триггер может удалить team_member, если у пользователя не осталось проектов этой команды
	RemoveProjectMember(context.Context, *RemoveProjectMemberRequest) (*emptypb.Empty, error)
	// Выдача/обновление прав участника проекта (только manager_rights)
	UpdateProjectMemberRights(context.Context, *UpdateProjectMemberRightsRequest) (*ProjectMember, error)
	// Пользователь подает заявку на вступление в проект
	RequestJoinProject(context.Context, *RequestJoinProjectRequest) (*ProjectJoinRequest, error)
	// Пользователь отменяет свою pending заявку
	CancelJoinProject(context.Context, *CancelJoinProjectRequest) (*ProjectJoinRequest, error)
	// Менеджеры проекта смотрят заявки
	ListProjectJoinRequests(context.Context, *ListProjectJoinRequestsRequest) (*ListProjectJoinRequestsResponse, error)
	// Менеджер проекта одобряет заявку: создаём project_member и помечаем request approved
	ApproveProjectJoinRequest(context.Context, *ApproveProjectJoinRequestRequest) (*ProjectJoinRequest, error)
	// Менеджер проекта отклоняет заявку
	RejectProjectJoinRequest(context.Context, *RejectProjectJoinRequestRequest) (*ProjectJoinRequest, error)
	mustEmbedUnimplementedProjectsServer()
}

// UnimplementedProjectsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProjectsServer struct{}

func (UnimplementedProjectsServer) CreateProject(context.Context, *CreateProjectRequest) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (UnimplementedProjectsServer) GetProject(context.Context, *GetProjectRequest) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProject not implemented")
}
func (UnimplementedProjectsServer) UpdateProject(context.Context, *UpdateProjectRequest) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProject not implemented")
}
func (UnimplementedProjectsServer) DeleteProject(context.Context, *DeleteProjectRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}
func (UnimplementedProjectsServer) ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjects not implemented")
}
func (UnimplementedProjectsServer) ListPublicProjects(context.Context, *ListPublicProjectsRequest) (*ListPublicProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPublicProjects not implemented")
}
func (UnimplementedProjectsServer) ListProjectMembers(context.Context, *ListProjectMembersRequest) (*ListProjectMembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjectMembers not implemented")
}
func (UnimplementedProjectsServer) AddProjectMember(context.Context, *AddProjectMemberRequest) (*ProjectMember, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProjectMember not implemented")
}
func (UnimplementedProjectsServer) RemoveProjectMember(context.Context, *RemoveProjectMemberRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveProjectMember not implemented")
}
func (UnimplementedProjectsServer) UpdateProjectMemberRights(context.Context, *UpdateProjectMemberRightsRequest) (*ProjectMember, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectMemberRights not implemented")
}
func (UnimplementedProjectsServer) RequestJoinProject(context.Context, *RequestJoinProjectRequest) (*ProjectJoinRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestJoinProject not implemented")
}
func (UnimplementedProjectsServer) CancelJoinProject(context.Context, *CancelJoinProjectRequest) (*ProjectJoinRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJoinProject not implemented")
}
func (UnimplementedProjectsServer) ListProjectJoinRequests(context.Context, *ListProjectJoinRequestsRequest) (*ListProjectJoinRequestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjectJoinRequests not implemented")
}
func (UnimplementedProjectsServer) ApproveProjectJoinRequest(context.Context, *ApproveProjectJoinRequestRequest) (*ProjectJoinRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveProjectJoinRequest not implemented")
}
func (UnimplementedProjectsServer) RejectProjectJoinRequest(context.Context, *RejectProjectJoinRequestRequest) (*ProjectJoinRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectProjectJoinRequest not implemented")
}
func (UnimplementedProjectsServer) mustEmbedUnimplementedProjectsServer() {}
func (UnimplementedProjectsServer) testEmbeddedByValue()                  {}

// UnsafeProjectsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectsServer will
// result in compilation errors.
type UnsafeProjectsServer interface {
	mustEmbedUnimplementedProjectsServer()
}

func RegisterProjectsServer(s grpc.ServiceRegistrar, srv ProjectsServer) {
	// If the following call pancis, it indicates UnimplementedProjectsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Projects_ServiceDesc, srv)
}

func _Projects_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_CreateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).CreateProject(ctx, req.(*CreateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetProject(ctx, req.(*GetProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_UpdateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).UpdateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_UpdateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).UpdateProject(ctx, req.(*UpdateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_DeleteProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).ListProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_ListProjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).ListProjects(ctx, req.(*ListProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_ListPublicProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPublicProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).ListPublicProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_ListPublicProjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).ListPublicProjects(ctx, req.(*ListPublicProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_ListProjectMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).ListProjectMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_ListProjectMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).ListProjectMembers(ctx, req.(*ListProjectMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_AddProjectMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProjectMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).AddProjectMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_AddProjectMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).AddProjectMember(ctx, req.(*AddProjectMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_RemoveProjectMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveProjectMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).RemoveProjectMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_RemoveProjectMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).RemoveProjectMember(ctx, req.(*RemoveProjectMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_UpdateProjectMemberRights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectMemberRightsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).UpdateProjectMemberRights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_UpdateProjectMemberRights_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).UpdateProjectMemberRights(ctx, req.(*UpdateProjectMemberRightsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_RequestJoinProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestJoinProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).RequestJoinProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_RequestJoinProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).RequestJoinProject(ctx, req.(*RequestJoinProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_CancelJoinProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJoinProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).CancelJoinProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_CancelJoinProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).CancelJoinProject(ctx, req.(*CancelJoinProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_ListProjectJoinRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectJoinRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).ListProjectJoinRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_ListProjectJoinRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).ListProjectJoinRequests(ctx, req.(*ListProjectJoinRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_ApproveProjectJoinRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveProjectJoinRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).ApproveProjectJoinRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_ApproveProjectJoinRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).ApproveProjectJoinRequest(ctx, req.(*ApproveProjectJoinRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_RejectProjectJoinRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectProjectJoinRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).RejectProjectJoinRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_RejectProjectJoinRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).RejectProjectJoinRequest(ctx, req.(*RejectProjectJoinRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Projects_ServiceDesc is the grpc.ServiceDesc for Projects service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Projects_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "workspace.v1.Projects",
	HandlerType: (*ProjectsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProject",
			Handler:    _Projects_CreateProject_Handler,
		},
		{
			MethodName: "GetProject",
			Handler:    _Projects_GetProject_Handler,
		},
		{
			MethodName: "UpdateProject",
			Handler:    _Projects_UpdateProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _Projects_DeleteProject_Handler,
		},
		{
			MethodName: "ListProjects",
			Handler:    _Projects_ListProjects_Handler,
		},
		{
			MethodName: "ListPublicProjects",
			Handler:    _Projects_ListPublicProjects_Handler,
		},
		{
			MethodName: "ListProjectMembers",
			Handler:    _Projects_ListProjectMembers_Handler,
		},
		{
			MethodName: "AddProjectMember",
			Handler:    _Projects_AddProjectMember_Handler,
		},
		{
			MethodName: "RemoveProjectMember",
			Handler:    _Projects_RemoveProjectMember_Handler,
		},
		{
			MethodName: "UpdateProjectMemberRights",
			Handler:    _Projects_UpdateProjectMemberRights_Handler,
		},
		{
			MethodName: "RequestJoinProject",
			Handler:    _Projects_RequestJoinProject_Handler,
		},
		{
			MethodName: "CancelJoinProject",
			Handler:    _Projects_CancelJoinProject_Handler,
		},
		{
			MethodName: "ListProjectJoinRequests",
			Handler:    _Projects_ListProjectJoinRequests_Handler,
		},
		{
			MethodName: "ApproveProjectJoinRequest",
			Handler:    _Projects_ApproveProjectJoinRequest_Handler,
		},
		{
			MethodName: "RejectProjectJoinRequest",
			Handler:    _Projects_RejectProjectJoinRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "teamAndProjects/teamAndProjects.proto",
}
